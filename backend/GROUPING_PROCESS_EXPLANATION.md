# Пошаговое объяснение процесса группировки и нормализации

## Общий обзор

Когда клиент отправляет запрос `POST /api/grouping/request`, запускается асинхронный pipeline, который проходит через 4 основных этапа (Step A-D) для преобразования сырых данных из `raw_products` в сгруппированные CTE сущности.

---

## Шаг 0: Прием запроса (Controller → Facade)

### 1. Controller получает запрос
```java
POST /api/grouping/request
Body: { "query": "найти все товары" }
```

### 2. GroupingFacadeImpl.createGroupingTask()
- **Создает задачу** в БД со статусом `IN_PROGRESS`
- **Запускает асинхронный pipeline** через `@Async`
- **Немедленно возвращает** `taskId` клиенту (не ждет завершения)

```java
Task created: UUID = abc-123, Status = IN_PROGRESS
→ Запуск pipeline в фоне
→ Возврат taskId клиенту
```

---

## Шаг A: Парсинг сырых данных (Parse Raw Products)

**Цель**: Преобразовать TEXT характеристики в структурированный JSONB формат и собрать все уникальные ключи.

### A1. Получение данных из `raw_products`
```sql
SELECT * FROM raw_products
```
Пример записи:
```
id: 1
title: "Стиральная машина Samsung"
characteristics: "Ширина:600 мм;Высота:850 мм;Глубина:550 мм;Вес:65 кг"
```

### A2. Парсинг характеристик для каждого продукта
**CharacteristicsParserService.parseCharacteristics()** разбирает строку:
```
"Ширина:600 мм;Высота:850 мм;Глубина:550 мм;Вес:65 кг"
```
↓
```json
{
  "Ширина": "600 мм",
  "Высота": "850 мм", 
  "Глубина": "550 мм",
  "Вес": "65 кг"
}
```

### A3. Сбор всех уникальных ключей
Во время парсинга собирается `Set<String> allRawKeys`:
```
["Ширина", "Высота", "Глубина", "Вес", "Ширина (мм)", "Width", "Mass", ...]
```
(примерно 300-400 уникальных ключей из всех продуктов)

### A4. Сохранение в `task_processing_items`
Для каждого продукта создается `TaskProcessingItemEntity`:
```java
{
  taskId: abc-123,
  rawProductId: 1,
  title: "Стиральная машина Samsung",
  characteristics: {  // JSONB
    "Ширина": "600 мм",
    "Высота": "850 мм",
    ...
  }
}
```

**Результат Step A**:
- ✅ Все продукты распарсены и сохранены в `task_processing_items`
- ✅ Собрано множество уникальных ключей (например, 350 ключей)

---

## Шаг B: Интеллектуальный слой (Intelligence Layer)

**Цель**: Найти синонимы, отфильтровать бесполезные атрибуты и сгенерировать схемы парсинга.

### B1. Кластеризация через Python ML

**PythonClusterClient.getClusters()** отправляет все уникальные ключи в Python ML сервис:

**Запрос**:
```json
POST http://localhost:8000/cluster_keys
{
  "keys": ["Ширина", "Высота", "Width", "Height", "Ширина (мм)", ...],
  "threshold": 0.4
}
```

**Ответ** (семантические кластеры):
```json
{
  "clusters": [
    ["Ширина", "Width", "Ширина (мм)", "Ширина мм"],
    ["Высота", "Height", "Высота (мм)"],
    ["Вес", "Mass", "Weight", "Масса"],
    ["Глубина", "Depth", "Глубина (мм)"],
    ...
  ]
}
```

**Результат**: 350 ключей → ~40-50 семантических кластеров

### B2. Фильтрация значимых кластеров

**SignificanceFilterService.filterSignificantClusters()** проверяет каждый кластер:

#### Проверка 1: Coverage (Покрытие)
- Кластер должен присутствовать минимум в **10% строк**
- Пример: если кластер `["Вес", "Weight"]` есть только в 5% продуктов → **отфильтрован**

#### Проверка 2: Cardinality (Уникальность)
- Если уникальных значений **≤ 1** → константа, **отфильтрован**
- Если уникальность **> 90%** → вероятно ID/серийный номер, **отфильтрован**

**Пример фильтрации**:
```
Кластер ["ID", "Идентификатор"]:
  - Coverage: 100% ✅
  - Cardinality: 99% (почти все значения уникальны) ❌ → ОТФИЛЬТРОВАН

Кластер ["Вес", "Weight", "Mass"]:
  - Coverage: 85% ✅
  - Cardinality: 15% (15 уникальных значений из 100) ✅ → ПРОШЕЛ
```

**Результат**: ~40 кластеров → ~20-25 значимых кластеров

### B3. Генерация схем через LLM

**OllamaService.generateSchemasForAllClusters()** отправляет значимые кластеры в LLM (Ollama):

**Запрос** (микро-батчами по 5 кластеров):
```json
[
  ["Ширина", "Width", "Ширина (мм)"],
  ["Высота", "Height", "Высота (мм)"],
  ["Вес", "Weight", "Mass"],
  ["Глубина", "Depth"],
  ["Цвет", "Color", "Colour"]
]
```

**Ответ** (схемы парсинга):
```json
{
  "Ширина": {
    "unified_name": "width",
    "display_name_ru": "Ширина",
    "data_type": "Numeric",
    "parsing_rule": {
      "regex": "(?<value>\\d+(?:\\.\\d+)?)\\s*(?<unit>mm|мм|cm|см)?",
      "base_unit": "mm",
      "unit_multipliers": {"cm": 10.0, "см": 10.0}
    }
  },
  "Высота": {
    "unified_name": "height",
    "display_name_ru": "Высота",
    "data_type": "Numeric",
    ...
  },
  ...
}
```

**Результат Step B**:
- ✅ Схемы для всех значимых кластеров
- ✅ Маппинг: `"Ширина" → "width"`, `"Width" → "width"`, `"Ширина (мм)" → "width"`

---

## Шаг C: Нормализация и группировка (Normalize & Group)

**Цель**: Нормализовать значения, сгруппировать продукты по важным атрибутам и создать CTE сущности.

### C1. Создание маппинга ключей

**createKeyToUnifiedNameMapping()** создает маппинг всех ключей кластера на `unified_name`:

```java
{
  "Ширина" → "width",
  "Width" → "width",
  "Ширина (мм)" → "width",
  "Высота" → "height",
  "Height" → "height",
  ...
}
```

### C2. Нормализация важных атрибутов для каждого продукта

Для каждого продукта из `task_processing_items`:

**Исходные данные**:
```json
{
  "Ширина": "600 мм",
  "Высота": "850 мм",
  "Вес": "65 кг",
  "Цвет": "Белый"
}
```

**Нормализация через DynamicParserEngine**:

1. **"600 мм"** → парсинг по regex `(?<value>\d+)\s*(?<unit>mm|мм)?`
   - Извлечено: `value = "600"`, `unit = "мм"`
   - Конвертация: `600 * 1.0 = 600.0` (мм - базовая единица)
   - Результат: `600.0`

2. **"65 кг"** → парсинг
   - Извлечено: `value = "65"`, `unit = "кг"`
   - Конвертация: `65 * 1000.0 = 65000.0` (кг → г)
   - Результат: `65000.0`

**Нормализованные важные атрибуты**:
```json
{
  "width": 600.0,
  "height": 850.0,
  "weight": 65000.0
}
```

### C3. Создание ключа группировки

**createGroupKey()** создает уникальный ключ из нормализованных важных атрибутов:

```java
normalizedImportant = {
  "width": 600.0,
  "height": 850.0,
  "weight": 65000.0
}

groupKey = "height=850.0|weight=65000.0|width=600.0"
```

**Важно**: Ключ сортируется по именам атрибутов для консистентности.

### C4. Группировка продуктов

Продукты с **одинаковым `groupKey`** объединяются в одну группу:

```
Группа 1 (groupKey: "height=850.0|weight=65000.0|width=600.0"):
  - Продукт 1: "Стиральная машина Samsung"
  - Продукт 5: "Стиральная машина Samsung WW80T554DAW"
  - Продукт 12: "Samsung Washer"

Группа 2 (groupKey: "height=900.0|weight=70000.0|width=600.0"):
  - Продукт 3: "Стиральная машина LG"
  - Продукт 8: "LG Washer"
```

### C5. Создание CTE сущностей

Для каждой группы создается **одна CTE сущность**:

**createCteFromGroup()**:

1. **Важные атрибуты** (использовались для группировки):
```json
[
  {"name": "width", "value": "600.0"},
  {"name": "height", "value": "850.0"},
  {"name": "weight", "value": "65000.0"}
]
```

2. **Второстепенные атрибуты** (остальные нормализованные):
```json
[
  {"name": "color", "value": "Белый"},
  {"name": "material", "value": "Пластик"}
]
```

3. **product_ids** (ID всех продуктов в группе):
```json
[1, 5, 12]
```

4. **image_url** (первый не-null из группы):
```
"https://example.com/images/samsung-washer.jpg"
```

**Итоговая CTE сущность**:
```json
{
  "id": "uuid-cte-1",
  "task_id": "abc-123",
  "image_url": "https://example.com/images/samsung-washer.jpg",
  "important_attributes": [
    {"name": "width", "value": "600.0"},
    {"name": "height", "value": "850.0"},
    {"name": "weight", "value": "65000.0"}
  ],
  "secondary_attributes": [
    {"name": "color", "value": "Белый"}
  ],
  "product_ids": [1, 5, 12]
}
```

**Результат Step C**:
- ✅ Все продукты сгруппированы по важным атрибутам
- ✅ Созданы CTE сущности (например, 1000 продуктов → 150 CTE)

---

## Шаг D: Финализация (Finalization)

**updateTaskStatus()** обновляет статус задачи:

```java
task.status = COMPLETED  // или FAILED при ошибке
```

---

## Пример полного потока данных

### Исходные данные (raw_products)

**Продукт 1**:
```
title: "Стиральная машина Samsung"
characteristics: "Ширина:600 мм;Высота:850 мм;Вес:65 кг;Цвет:Белый"
```

**Продукт 2**:
```
title: "Samsung Washer WW80T554DAW"
characteristics: "Width:600 mm;Height:850 mm;Weight:65 kg;Color:White"
```

### После Step A (task_processing_items)

**Продукт 1**:
```json
{
  "characteristics": {
    "Ширина": "600 мм",
    "Высота": "850 мм",
    "Вес": "65 кг",
    "Цвет": "Белый"
  }
}
```

**Продукт 2**:
```json
{
  "characteristics": {
    "Width": "600 mm",
    "Height": "850 mm",
    "Weight": "65 kg",
    "Color": "White"
  }
}
```

### После Step B (схемы)

```json
{
  "Ширина": {
    "unified_name": "width",
    "data_type": "Numeric",
    "parsing_rule": {...}
  },
  "Width": {
    "unified_name": "width",  // Тот же unified_name!
    ...
  }
}
```

### После Step C (CTE)

**Одна CTE сущность для обоих продуктов**:
```json
{
  "important_attributes": [
    {"name": "width", "value": "600.0"},
    {"name": "height", "value": "850.0"},
    {"name": "weight", "value": "65000.0"}
  ],
  "product_ids": [1, 2]  // Оба продукта в одной группе!
}
```

---

## Ключевые моменты

1. **Асинхронность**: Клиент получает `taskId` сразу, обработка идет в фоне
2. **Семантическая кластеризация**: ML находит синонимы ("Ширина" = "Width")
3. **Статистическая фильтрация**: Удаляются бесполезные атрибуты (ID, константы)
4. **Нормализация**: Все значения приводятся к единому формату (600 мм = 600.0)
5. **Группировка**: Продукты с одинаковыми важными атрибутами объединяются
6. **Транзакционность**: Каждый этап в своей транзакции для надежности

---

## Временная диаграмма

```
T0: POST /api/grouping/request
    ↓
T1: Task created (IN_PROGRESS) → taskId возвращен клиенту
    ↓ [Асинхронно]
T2: Step A - Парсинг (5-10 сек)
    ↓
T3: Step B - ML + LLM (30-60 сек)
    ↓
T4: Step C - Нормализация + Группировка (10-20 сек)
    ↓
T5: Step D - Статус = COMPLETED
```

**Общее время**: ~45-90 секунд (в зависимости от объема данных)

